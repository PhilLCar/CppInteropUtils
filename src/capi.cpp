#include <capi.h>

#include <iostream>

#include <tokenizer.h>
#include <parser.h>

namespace interop {
  CAPI::CAPI(const char* preprocessedFilename, const vector<const char*>& includePaths)
  {
    Tokenizer tokenizer(preprocessedFilename, includePaths);
    Parser::parse(tokenizer, root);
  }

  CAPI::~CAPI()
  {
  }

  void CAPI::makeC(const char* output) {
    string cpp_name = string(output) + ".cpp";
    string c_name   = string(output) + ".h";
    ofstream cpp;
    ofstream c;

    cpp.open(cpp_name, ios::out);
    c.open(c_name, ios::out);

    printHeader(cpp);
    printHeader(c);
    _includeC(cpp, root);
    c << "#pragma once" << endl << endl;
    cpp << endl << "extern \"C\" {" << endl;

    _makeC(c, cpp, root);

    cpp << "}" << endl;
  }

  void CAPI::_includeC(ofstream& cpp, const Object& object)
  {
    if (object.file.length() > 0) cpp << "#include " << object.file << endl;
    for (vector<Object>::const_iterator it = object.objects.begin(); it != object.objects.end(); it++) _includeC(cpp, *it);
  }

  void CAPI::_makeC(ofstream& c, ofstream& cpp, const Object& object)
  {
    for (vector<Object>::const_iterator it = object.objects.begin(); it != object.objects.end(); it++) _makeC(c, cpp, *it);

    for (vector<Prototype>::const_iterator it = object.prototypes.begin(); it != object.prototypes.end(); it++) {
      c << it->toString() << endl;
    }
  }

  void CAPI::printHeader(ofstream& out)
  {
    out << "/////////////////////////////////////////////////////////////////////////////////////////////////" << endl;
    out << "// This document was programatically generated by the C Automated Programming Interface (CAPI) //" << endl;
    out << "// For more information, visit: http://www.github.com/PhilLCar/CppInteropUtils                 //" << endl;
    out << "/////////////////////////////////////////////////////////////////////////////////////////////////" << endl;
    out << endl;
  }
}